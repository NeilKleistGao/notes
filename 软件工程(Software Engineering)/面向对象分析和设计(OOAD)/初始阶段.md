# 初始阶段
考虑的问题：
+ 项目设想和业务案例
+ 可行性分析
+ 购买还是开发？
+ 粗略的成本估计
+ 继续开发还是终止项目？

初始阶段的目标并不是定义所有需求，大多数需求分析在细化阶段完成，并且伴以具有产品品质的早期编程和测试。

预见项目的范围、设想和业务案例，涉众就项目设想基本达成一致。

初始阶段制品的样例：
+ 设想和业务模型
+ 用例模型
+ 补充性规格说明
+ 词汇表：关键领域术语和数据字典
+ 风险列表和风险管理计划
+ 原型和概念验证：澄清设想，验证技术思路
+ 迭代计划
+ 阶段计划和软件开发计划
+ 业务案例：就特定项目，对步骤和制品进行定制的描述

初始阶段**绝不会引入大量图形。**

# 进化式需求
需求就是系统必须提供的能力和必须遵从的条件。UP更推崇用“一种系统的方法来寻找，记录，组织和跟踪系统不断变更的需求”。

`FURPS+`分类：
+ 功能性(Functinal)：特性，功能
+ 可用性(Usability)：人性化因素，文档
+ 可靠性(Reliability)：故障频率，可恢复性，可预测性，安全性
+ 性能(Performance)：响应时间，资源利用率，吞吐量，并发量
+ 可支持性(Supportability)：可维护性，国际化，可配置性
+ `+`：辅助行和次要性的因素，如：实现，接口，操作，包装，授权

需求制品：
+ 用例模型
+ 补充性规格说明：非功能性需求+不能表示为用例的需求
+ 词汇表：数据字典（数据需求，有效性规则，容许值等）
+ 设想
+ 业务规则

# 用例(use case)
用例的本质是通过编写使用系统实现用户目标的情节来发现和记录功能性需求。用例就是一组相关的陈宫和失败场景集合，用来描述参与者如何使用系统来实现其目标。

**用例不是图形，而是文本。**

参与者是某些具有行为的事物（人、系统或组织）;场景是参与者和系统之间的一系列特定的活动和交互，也称为用例实例。

场景记录：
+ 参与者之间的交互
+ 确认过程（通常由系统完成）
+ 系统完成的状态变更

用例不是面向对象的，编写用例时也不会进行OO分析。

缺少用户参与是项目失败的主要原因，用例降低了这项工作的难度，且强调了用户的目标和观点。

参与者的三种类型：
+ 主要参与者：具有用户目标，并通过使用所讨论的系统的服务完成
+ 协助参与者：为所讨论的系统提供服务
+ 幕后参与者：在用例中具有影响或利益的其他参与者

## 详述用例
+ 用例名称
+ 范围：用例描述的是对一个系统的使用，则称之为系统用例;对于更广泛的范围，称之为业务用例
+ 级别：用户目标级别相当于基本业务流程;子功能级别的用例描述支持用户目标所需要的子步骤
+ 主要参与者
+ **涉众及其关注点列表**：用例应该包含满足所有涉众关注点的事物。在编写用例其余部分前确定涉众及其关注点，能更加清楚地了解详细的系统职责
+ 前置条件
+ 后置条件
+ 主成功场景和步骤（基本流程）：通常不包括任何条件和分支，保持一定的连惯性
+ 扩展（替代流程）：基本流程与替代流程相结合应该满足几乎所有涉众所关注的问题。扩展由两部分组成：条件和处理。对于任何步骤都有可能发生的条件，使用`*`标记，使用下划线表示所执行的第二个用例
+ 特殊需求：非功能性需求，质量属性和约束
+ 技术和数据变元表：如何实现系统

## 用例编写准则
+ 以无用户界面约束的本质风格编写用例，摒弃用户界面于思考范围之外
+ 在早期需求工作中避免具体，使用黑盒用例
+ 如何发现用例？确定系统边界->寻找主要参与者和目标（时间，系统重启，升级处理）->定义用例
+ 保留有用的用例：老板测试，EBP测试（增加可量化的业务价值），规模测试

## 如何使用用例
UP提倡用例驱动开发(use-case driven development)。
+ 功能首先记录在用例中
+ 用例是迭代计划的重要部分，也是预算的关键输入
+ 用例实现驱动设计
+ 用例影响用户手册的组织
+ 功能或系统测试应当符合用例场景

当详细定义了约10%的需求时，技术小组需要开始构建系统的产品化核心。

# 其他需求
在早期花费一定时间去理解非功能性需求是有帮助的，这对架构选择有重要影响。

用例的“特殊需求”应该被归进补充性规格说明。

设想不应占据很长的篇幅。但不要在设想中只列出用例名：
+ 用例很多，太详细且层次低，人们需要主要思想的概要
+ 用例名称可能掩盖了涉众真正关心的主要特性
+ 有些特性跨越了多个用例或用例无关

先编写设想还是先编写用例？不需要严格定义，建议：
+ 编写简要的设想草案
+ 确定用户目标和对应的用例名称
+ 详细编写用例，并开始编写补充性规格说明
+ 精化设想

数据字典，记录关于数据的数据（元数据）文档，包括：
+ 别名
+ 描述
+ 格式（类型，长度，单位）
+ 与其他元素的关系
+ 值域
+ 验证规则
