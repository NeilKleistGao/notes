# 迭代2
迭代1结束时，应该完成以下任务：
+ 所有软件已经被充分测试：单元、验收、负载、可用性等
+ 客户定期参与对已完成部分的评估，从而使开发人员获得对调整和澄清需求的反馈
+ 已对系统进行了完整的集成和固化，使其成为基线化的内部版本

# 更多GRASP模式
## 多态
问题：如何处理基于类型的选择（减少条件变化`if-then-else`）？如何创建可插拔的软件构件？

解决方案：当相关选择或行为随类型不同而有所不同时，使用多态操作为变化的行为类型分配职责。

准则：
+ 除非在超类中有默认的行为，否则将超类中的多态方法声明为`{abstract}`
+ 当你想要支持多态但是又不想约束于特定的类层次结构的时候，使用接口

优点：
+ 易于增加新变化所需要的扩展
+ 无需影响客户便能引入新的实现

## 纯虚构
问题：当你不想违背高内聚和低耦合或其他目标，但基于专家模式的方案又不适合时，哪些对象应该承担这一职责？

解决方案：对人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念——穷途末路时所捏造的某物。

优点：
+ 支持高内聚，因为职责被解析为细粒度的类
+ 增加了潜在的复用性，这些类的职责可以用于其他地方

## 间接性
问题：为了避免两个或多个事物之间直接耦合，应该如何分配职责？如何使对象解耦合，以支持低耦合并提高复用性潜力？

解决方案：将职责分配给中间对象，使其作为其他构件或服务之间的媒介，以避免他们的直接耦合。中介实现了其他构件之间的间接性。

优点：
+ 实现了构建之间的低耦合

## 防止变异
问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？

解决方案：识别预计变化和不稳定之处，分配职责用以在这些变化之外创建稳定接口。

不要和陌生人讲话，只应该给以下对象发送消息：
+ this对象
+ 方法参数
+ this属性
+ this属性集合中的元素
+ 在方法中创建的对象

优点：
+ 易于增加新变化所需要的扩展
+ 可以引入新的实现而无需影响客户
+ 低耦合
+ 降低变化的成本或影响

开放-封闭原则：对扩展/可适应性开放，对影响客户的更改关闭。

# GoF设计模式
## 适配器
问题：如何解决不相容的接口问题，或者如何为具有不同接口的类似构件提供稳定的接口？

解决方案：通过中介适配器对象，将构件原有的接口转换为其他接口。

适配器支持防止变异，因为它通过应用了接口的多态和间接对象，改变了外部接口或第三方软件包。需要找到根本原则。大多数设计模式可以被视为少数几个GRASP基本原则的特化。

如领域模型在将来会被用作后续设计工作的输入，或者作为学习关键领域概念的手段，那么对领域模型的增补是有价值的。

## 工厂
别名：具体工厂

问题：当有特殊考虑，如在创建时存在复杂逻辑，为了改良内聚而分离创建职责等，应该由谁来负责创建对象？

解决方案：创建称为工厂的纯虚构对象来处理这些创建职责。

## 单例
问题：只有唯一实例的类即为单例类，对象需要全局可见性和单点访问。

解决方案：对类定义静态方法用以返回单例。

使用缓式初始化的理由：
+ 如果实例永远不会被访问，就会节省创建工作
+ 创建步骤可能包含复杂和有条件的创建逻辑

不使用静态类的理由：
+ 实例方法允许定义子类以进行精化
+ 远程通信机制大多只支持实例方法的使用
+ 类并非在所有场景下都是单例的

## 策略
问题：如何设计变化但相关的算法或政策？如何才能使其具有可变能力？

解决方案：在单独的类中分别定义每种算法/政策/策略，并使其具有相同接口。

## 组合
问题：如何能够像处理非组合（原子）对象一样，多态地处理一组对象或具有组合结构的对象呢？

解决方案：定义组合和原子对象的类，使他们实现相同的接口。

## 外观
问题：对一组完全不同的实现或接口需要公共、统一的接口。可能会与子系统内部的大量事物产生耦合，或者子系统的实现可能会改变，怎么办？

解决方案：对子系统定义唯一接触点——使用外观对象封装子系统。该外观对象提供了唯一和统一的接口，并负责与子系统构件进行协作。

## 观察者
别名：发布-订阅，委派事件模型
问题：不同类型的订阅者对象关注于发布者对象的状态变化或事件，并且想要在发布者产生事件时以自己独特的方式作出反映。此外，发布者想要保持与订阅者的低耦合，如何进行设计？

解决方案：定义订阅者或监听者接口。订阅者实现此接口。发布者可以动态注册关注某事件的订阅者，并在事情发生时通知他们。