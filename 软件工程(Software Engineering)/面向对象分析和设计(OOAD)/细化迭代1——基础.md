# 基础
细化包括：
+ 对核心、有风险的软件架构进行编程和测试
+ 发现并稳定需求的主体部分
+ 规避主要风险

细化不是设计阶段，也不要完成所有模型的开发。

架构原型(architectural prototype，可执行架构或架构基线)不是可以丢弃的原型，而是具有产品品质的最终系统的一部分。

# 领域模型
领域模型(domain model)是对领域内的概念类或现实世界中对象（而非软件对象）的可视化表示。

领域模型描述的信息也可以采用纯文本的方式表示。

软件对象的领域层：在表示层或UI层之下的软件对象层是由领域对象组成的——领域对象是表示问题领域空间的事物的软件对象，并且与业务逻辑或领域逻辑方法相关。

概念类是思想，事物或对象。符号是表示概念类的词语或图形。内涵即概念类的定义，外延为概念类所适用的一组示例。

领域模型不是数据模型，没有属性的概念类是合法的。

**动机：降低与OO建模之间的表示差异**

如何创建领域模型：
+ 寻找概念类
+ 将其绘制为UML类图中的类
+ 添加关联和属性

## 概念类
找到概念类的三个策略：
+ 重用和修改现有的模型
+ 使用分类列表：概念类的候选列表，建议加入优先级
+ 确定名词短语：语言分析

是否使用工具来维护模型：谁要使用这些更新的模型？为什么？

像地图绘制者的工作思维创建领域模型：使用地域中现有的名字，排除无关或超出范围的特性，不要凭空增加事物。

对于非现实世界，需要高度抽象，汲取领域专家所使用的核心词汇和概念。

如果我们认为概念类X不是现实中的数字或文本，那么X很有可能是概念类而不是属性。

使用描述类：如商品（实体）和商品描述（描述或抽象），或用于减少冗余信息（商品只需要对应一个描述类，而不需要包含详细信息）。

## 关联
关联是类的实例之间的关系，是否需要记录关联，要基于现实世界的需要，而不是基于软件的需要。以“类名-动词短语-类名”为关联命名。

关联的多重性定义了类A有多少个实例可以和类B的一个实例相关联。两个类之间可能存在多重关联。

## 属性
属性是对象的逻辑数据值。属性的完整语法：
```
可见性(public/private) 名称(first name): 类型(string/date) 可选值([0..1]) = 默认值(114514) {特性表(readonly)}
```

建议把所有的属性需求转移到词汇表中。

导出属性：由多重性的值导出，使用`/`标记。

大部分的属性类应该是简单的，通过关联而不是属性来表示概念类之间的关系。

何时需要定义新的类型：
+ 由不同小节组成（电话号码，人名）
+ 具有与之相关的操作（解析和校验）
+ 具有其他属性
+ 单位

属性不应表示概念类的关系，不要使用外键属性。

## 结论
领域模型是否正确没有唯一答案！

# 系统顺序图(SSD)
系统顺序图是为阐述与所讨论系统相关的输入和输出事件而快速、简单地创建的制品。

在交互中，参与者对系统发起系统事件，通常需要某些系统操作对这些事件加以处理。

系统顺序图表示的是，对于用例的一个特定场景，外部参与者产生的事件，其顺序和系统之内的事件。

SSD中的所示元素（操作名称、参数、返回的数据）是简洁的。

## 迭代和进化式SSD
只需要为下一次迭代所需要的场景绘制SSD。

+ 初始阶段通常不会引入SSD
+ 大部分的SSD在细化阶段创建

# 操作契约
操作契约的关键元素是后置条件。

## 定义
```
操作：操作的名称和参数
交叉引用：会发生此操作的用例
前置条件：执行操作前，对系统或领域模型对象状态的重要假设
后置条件：完成操作后，领域模型对象的状态
```

可以为系统操作定义操作契约，系统操作是作为黑盒构建的系统在其公共接口中提供的操作。

## 后置条件
后置条件描述了领域模型对象的状态的变化。领域模型状态变化包括：
+ 创建/删除实例
+ 属性值的变化
+ 形成或消除关联

后置条件不是在操作过程中执行的活动。后置条件不是必须的，为所有系统操作生成完整详细的后置条件是不可能的，或者是没有必要的。

如何编写后置条件：用过去时态表达后置条件，以强调它们是由操作引起的状态变化的观察结果。

## 如何编写契约
+ 从SSD中确定系统操作
+ 如果系统操作复杂，结果不明显，或者在用例中不清楚，则为其构造操作契约

## 应用UML
UML中操作的定义：操作时可以调用对象执行的转换或查询的规格说明。在UML中，操作是抽象而非实现。方法是操作的实现，它规定了与操作关联的算法或过程。

OCL（对象约束语言）可以用来表示UML操作的约束。

# 逻辑架构和UML包图
## 什么是逻辑架构和层
逻辑架构是软件类的宏观组织结构，它将软件类组织为包（或命名空间）、子系统和层等。

层是对类、包或子系统的身为粗粒度的分组。

OO系统中通常包括的层：
+ 用户界面
+ 应用逻辑和领域对象
+ 技术服务


在严格的分层架构中，层只能调用与其相邻的下层的服务；在宽松的分层架构中，较高层可以调用其下任何层的服务。

所有软件架构定义的共同主题是，必须与宏观事务有关——动机、约束、组织、模式、职责和系统之连接的重要思想。

## 应用UML
人们通常希望显示包之间的依赖性（耦合）。UML的依赖线可以用于此目的：依赖线是由箭头的虚线，箭头指向被依赖的包。

## 准则
使用层有助于解决如下的问题：
+ 源码的变更波及整个系统
+ 应用逻辑与用户界面交织在一起
+ 潜在的一般性技术服务或业务逻辑与特定于应用的逻辑交织在一起
+ 不同的关注领域之间高度耦合

使用层的好处：
+ 关系分离、高级服务与低级服务分离、特定服务与一般性服务分离，减少耦合，增强内聚
+ 封装和分解了相关复杂性
+ 某些层可以替换
+ 较低层可以包含复用功能
+ 某些层可以是分布式的
+ 通过逻辑划分，有助于团队开发

准则：内聚职责，关系分离。

如何使用对象设计应用逻辑？创建软件对象，使其名称和信息类似于真实世界的领域，并为其分配应用逻辑职责。

架构中的层表示对系统在垂直方向的划分，而分区表示对层在水平方向进行划分。

不要将外部资源表示为最底层。

模型-视图分离原则：
+ 不要将非UI对象直接与UI对象连接或耦合
+ 不要在UI对象方法中加入应用逻辑

模型-视图分离的动机：
+ 支持内聚的模型定义，只关注逻辑而不是界面
+ 允许模型和用户界面分别开发
+ 使界面的需求变更对模型影响最小化
+ 允许新视图可以被方便地接在现有领域层上
+ 允许对同一个模型使用多个视图
+ 允许模型不依赖于用户界面
+ 允许模型层简便地移植

## 迈向对象设计
敏捷建模的目的是为理解和沟通而不是构建文档。

敏捷建模包括：
+ 绘制UML草图
+ 与其他人一同建模
+ 并行创建若干模型

## 静态建模和动态建模
动态模型有助于设计逻辑、代码行为或者方法体，例如UML交互图（顺序图或通信图）。

静态模型设计包、类名、属性和方法特征标记的定义。

类职责写作（CRC）卡是流行的面向对象文本建模技术。

# UML交互图
UML使用交互图来描述对象间通过消息的交互。

交互图有两种：
+ 顺序图
+ 通信图

| 类型 | 优势 | 劣势 |
| --- | --- | --- |
| 顺序图 | 清晰表示消息顺序和时间顺序，大量详细表示法选项 | 强制在右侧增加对象，消耗水平空间 |
| 通信图 | 空间效用——能够在二维空间内灵活增加对象 | 不易查阅消息顺序，表示法选项较少 |

应该花费时间使用交互图进行动态对象建模，而不是仅使用类图进行静态对象建模。

## UML图表示法
### 顺序图表示法
+ 在垂直生命线之间，用带实心箭头的实现并附以消息表达式的方法表示对象间的每个消息（同步）。
+ 最开始的消息在UML中称为创始消息，以实心圆作为起点
+ 执行规格条用于表示控制期
+ 使用消息语法 `returnVal = message(parameter)`或者在活动条末端使用应答消息线（虚线刺型箭头）
+ 实例创建使用虚线实心箭头，被创建的对象被置于其创建高度上
+ 销毁时需要使用`×`和短生命线表示
+ 顺序图中的图框：

| 图框操作符 | 含义 |
| --- | --- |
| alt | 选择性片段，表示互斥逻辑 |
| loop | 循环片段，可以写作loop(n)或类似for的形式 |
| opt | 当保护信息为真时可以执行 |
| par | 并行执行的片段 |
| region | 临界片段 |

+ 动作图框可以包含任意语句（如`i++`）
+ 交互具体值（也称为交互使用）是在交互中引用另一交互（使用ref图框表示）
+ 发送到`<<metaclass>>`的消息为静态方法调用
+ 使用多个顺序图表示多态消息
+ 使用刺型箭头消息表示异步调用
+ 在生命框图两侧加双竖线来表示主动对象，其执行自己的线程实例

### 通信图的表示法
+ 链是连接两个对象的路径，指明对象间某种可能的导航和可见性，消息会延此链流转
+ 消息使用消息表达式和指明消息方向的箭头表示，可以增加顺序编号以表示当前控制线的消息次序（不要为起始消息编号）
+ 自身可以向自身发送消息
+ `create`消息表示实例的创建，使用其他名称需要使用构造型（`<<create>>`）加以注释
+ 消息嵌套需要使用附加数字
+ 有条件的消息使用方括号表示
+ 互斥的条件路径需要使用字母修改顺序编号
+ 迭代/循环使用`*`和可选的迭代子句（如`[i = 1..n]`）
+ 静态调用、多态、异步调用同顺序图

# UML类图
类元：描述行为和结构特性的模型元素，是众多UML元素的范化。最常用的类元是类和接口。

## 表示方法
+ 表示UML属性：属性文本+关联线，属性文本的完整格式是`visibility name : type multiplicity = default {property-string}`，导航性箭头有源对象指向目标对象，角色名只放在目标的一端，表示名称。对数据类型对象使用属性文本表示法，对其他对象使用关联线。关联末端也可以使用特性字符串
+ 操作和方法：完整语法格式是`visibility name (param-list) : return-type {property-string}`。方法使用构造型为`<<method>>`的UML注解符号（定义了动态行为）
+ 构造函数需要使用构造型`<<constructor>>`
+ 过滤掉恼人的getter/setter
+ 关键字：

| 关键字 | 含义 | 用法示例 |
| --- | --- | --- |
| `<<actor>>` | 类元为参与者 | 在类图中置于类元上方 |
| `<<interface>>` | 类元为接口 | 在类图中置于类元上方 |
| `{abstract}` | 抽象元素，不能实例化 | 置于类元名称或操作名称后 |
| `{ordered}` | 具有强制顺序的一组对象 | 置于关联的端点 |

+ 构造型表示对现有建模概念的精化，并且定义在UML简档中
+ 特性是表示元素特征的已命名的值，特性具有语义影响
+ 范化与继承不一定相同，抽象类还可以使用斜体名称来表示
+ 终止 类和不能够被子类复写的操作使用`{leaf}`标记
+ 依赖用从客户元素到提供者元素的虚线箭头表示，并且表示当提供者有所改变时会对客户元素产生影响。依赖可以视为耦合的另一个版本，包括：拥有提供者类型的属性、向提供者发送消息、接收提供者类型的参数、提供者是超类或者接口。可以为依赖线附加关键字或构造型
+ 接口支持插座线表示法（依赖于接口）、依赖线表示法（依赖于接口）、棒棒糖表示法（实现并提供了接口）、虚线空心箭头（指向接口）
+ 不要费心使用聚合，相反，在适当的时候使用组合：在某一时刻，部分实例只属于一个组成实例；部分必须总是属于组成；组成要负责创建和删除起部分
+ 约束时对UML元素的限制或条件（如`{size >= 0}`）
+ 限定关联具有限定符，限定符用于从规模较大的相关对象集合中，依据限定符的键选择一个或多个对象
+ 关联类允许将关联本身作为类
+ 单例类在右上角标记`1`
+ 模板参数使用虚线框标记在右上角，模板绑定时在类后标记（如`ArrayList<T->Square>`）
+ 用户可以添加自定义的分栏
+ 主动类使用双竖线表示

# GRASP：基于职责设计对象
**最关键的软件开发工具是受过良好设计原则训练的思维，而不是其他技术。**

在建模日中，我们需要画出交互图，并画出补充性的类图。在这些活动当中，需要应用各种OO设计原则，如GRASP和GoF设计模式。

## 职责和职责驱动设计
思考软件对象设计以及大型构建的流行方法是，考虑其职责、角色和协作。UML把职责定义为“类元的契约或义务”。

对象的行为职责包括：
+ 自身执行一些行为，如创建对象或计算
+ 初始化其他对象的动作
+ 控制和协调其他对象的动作

对象的认知职责包括：
+ 对私有封装数据的认知
+ 对相关对象的认知
+ 对其能导出或计算的事物的认知

## GRASP和模式
GRASP是使用职责进行OO设计的学习工具。

有经验的OO开发者建立了既有通用原则又有惯用方案的指令系统来指导他们编制软件。如果以结构化的形式对这些问题、解决方案和命名进行描述使其系统化，那么这些原则和习惯用法就可以称为模式。

GRASP定义了九个基本OO设计原则或基本设计构件。如：
+ 创建者
+ 信息专家
+ 低耦合
+ 控制器
+ 高内聚

### 创建者
名称：创建者

问题：谁创建了A？

解决方案：如果以下条件之一为真时，可以将创建类A的实例的职责分配给类B：
+ B包含或者组成聚集了A
+ B记录了A
+ B紧密地使用A
+ B具有A的初始化数据

### 信息专家
名称：信息专家

问题：给对象分配职责的基本原则是什么？

解决方案：把职责分配给具有完成该职责的所需信息的那个类。

### 低耦合
名称：低耦合

问题：如何减少因变化产生的影响？

解决方案：分配职责以使耦合保持在最低水平。

### 控制器
名称：控制器

问题：在UI层之上首先接收和协调系统操作的对象是什么？

解决方案：把职责分配给能代表下列选择之一的对象：
+ 代表全部“系统”、“根对象”、运行软件的设备或主要的子系统
+ 代表发生系统操作的用例场景

### 高内聚
名称：高内聚

问题：怎样使对象保持有内聚、可理解和可管理，同时具有低耦合的附加作用？

解决方案：职责分配应保持高内聚，依此来评估备选方案。

## 用例实现
用例实现描述某个用例基于协作对象如何在设计模型中实现。

让客户尽量参与。

# 可见性设计
可见性是对象“看到”或引用其他对象的能力。可见性与范围问题有关：某一资源（例如实例）是否在另一资源的范围之内。

实现对象A到对象B的可见性有四种方法：
+ 属性可见性：B是A的属性
+ 参数可见性：B是A中方法的参数
+ 局部可见性：B是A中方法的局部参数
+ 全局可见性：B具有某种方式的全局可见性

为了使对象A能够向对象B发送消息，对于A而言，B必须是可见的。

# 测试驱动开发和重构
## 测试驱动开发
测试驱动开发是迭代和敏捷XP方法提倡的优秀实践，该实践也称为测试优先开发。TDD要在测试类之前编写测试代码，并且在开发者要为几乎所有的产品代码编写单元测试代码。

优点：
+ 能够保证编写单元测试
+ 使程序员获得满足感从而更始终如一地坚持编写测试
+ 有助于澄清接口和行为的细节
+ 可证明、可再现、自动的验证
+ 改变事物的信心

## 重构
重构是重写或重新构建已有代码的结构化和规律性方法，但不会改变已有代码的外在行为，而是采用一系列少量的转换步骤，并且每一步都结合了重新执行的测试。

重构的目的：
+ 去除冗余的代码
+ 改善清晰度
+ 使过长的方法变得较短
+ 去除硬编码的字面常量
+ ……

进行良好重构的代码应该是简短、紧凑、清晰的，并且没有冗余。

坏味代码的特点：
+ 冗余的代码
+ 大型方法
+ 具有大量实例变量的类
+ 明显相似的子类
+ 在设计中很少使用或者没有使用的接口
+ 许多对象之间有很多耦合度
+ 包含大量其他的垃圾代码

常用方法：
+ 提炼方法
+ 提炼常量
+ 引入解释变量
+ 使用工厂方法